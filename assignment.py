# -*- coding: utf-8 -*-
"""assignment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1elhzi_DbaKf6rHXFsWHjEsVZ9G1hQiZn
"""

from pandas import read_csv
from pandas.plotting import scatter_matrix
from matplotlib import pyplot
from sklearn.model_selection import train_test_split
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import StratifiedKFold
from sklearn.metrics import classification_report
from sklearn.metrics import confusion_matrix
from sklearn.metrics import accuracy_score
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis
from sklearn.naive_bayes import GaussianNB
from sklearn.svm import SVC
import spacy

dataset = read_csv('/content/drive/My Drive/Colab Notebooks/Knight assignment/Data/train.csv')
dataset['country'][dataset['country'].isnull()] = 'None'
dataset['designation'][dataset['designation'].isnull()] = 'None'
dataset['province'][dataset['province'].isnull()] = 'None'
dataset['region_1'][dataset['region_1'].isnull()] = 'None'
dataset['region_2'][dataset['region_2'].isnull()] = 'None'
dataset['winery'][dataset['winery'].isnull()] = 'None'
dataset['price'][dataset['price'].isnull()] = dataset['price'].mean()
dataset['points'][dataset['points'].isnull()] = dataset['points'].mean()

pyplot.bar(dataset['variety'].unique(), dataset['variety'].value_counts())
pyplot.scatter(dataset['price'], dataset['variety'])#price also evenly spread except few, if want can be an option
pyplot.scatter(dataset['country'], dataset['variety'])#evenly spread except few, if want can be an option or not
pyplot.scatter(dataset['points'], dataset['variety'])#points are evenly spread
pyplot.scatter(dataset['region_2'], dataset['variety'])#uniform
dataset['designation'].nunique()#26425, skip
dataset['province'].nunique()#359, can be feature
dataset['region_1'].nunique()
dataset['region_2'].nunique()

nlp = spacy.load("en_core_web_sm")
X = dataset.iloc[:,2:4].values#only review title and description as potential features 
Y = dataset.iloc[:,11].values
data = []
docs = X[:,0].tolist()
filter = []
for text in nlp.pipe(docs):
  tokens = [token for token in text if token.pos_ == "NOUN"]
  t = " ".join(tokens)
  filter.append(t)
from sklearn.feature_extraction.text import CountVectorizer
cv = CountVectorizer()
wm = cv.fit_transform(filter)

def wm2df(wm, feat_names):
    
    # create an index for each row
    doc_names = ['Doc{:d}'.format(idx) for idx, _ in enumerate(wm)]
    df = DataFrame(data=wm.toarray(), index=doc_names,
                      columns=feat_names)
    return(df)

from pandas import DataFrame
feat = cv.get_feature_names()
wm2df(wm, feat)
data = pd.concat(data, wm2df, axis = 1)

docs = X[:,1].tolist()
filter = []
for text in nlp.pipe(docs):
  tokens = [token for token in text if token.pos_ == "NOUN"]
  t = " ".join(tokens)
  filter.append(t)
wm = cv.fit_transform(filter)
wm2df(wm, feat)
data = pd.concat(data, wm2df, axis = 1)
X = data



X_train, X_val, Y_train, Y_val = train_test_split(X, Y, test_size=0.20, random_state=1)

models = []
models.append(('LR', LogisticRegression(solver='liblinear', multi_class='ovr')))
models.append(('LDA', LinearDiscriminantAnalysis()))
models.append(('KNN', KNeighborsClassifier()))
models.append(('CART', DecisionTreeClassifier()))
models.append(('NB', GaussianNB()))
models.append(('SVM', SVC(gamma='auto')))
results = []
names = []
for name, model in models:
	kfold = StratifiedKFold(n_splits=10, random_state=1, shuffle=True)
	cv_results = cross_val_score(model, X_train, Y_train, cv=kfold, scoring='accuracy')
	results.append(cv_results)
	names.append(name)
	print('%s: %f (%f)' % (name, cv_results.mean(), cv_results.std()))
	
pyplot.boxplot(results, labels=names)
pyplot.title('Comparison')
pyplot.show()
# best accuracy for svm so we will go forward with svm

model = SVC(gamma='auto')
model.fit(X_train, Y_train)
predictions = model.predict(X_validation)
print(accuracy_score(Y_validation, predictions))